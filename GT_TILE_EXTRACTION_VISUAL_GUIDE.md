# GT Tile提取可视化指南

## 🎨 核心概念图解

### 场景1: LR和GT尺寸相同

```
原始LR图片: 128x128
     ┌─────────────┐
     │             │
     │   128x128   │  bicubic
     │             │  upsample    上采样LR: 512x512
     └─────────────┘  ────────>   ┌─────────────────────┐
                                  │                     │
                                  │                     │
                                  │      512x512        │
                                  │                     │
                                  └─────────────────────┘
                                           │
                                           │ Tile切分
                                           ▼
                      ┌──────────┬──────────┬──────────┐
                      │ Tile 1   │ Tile 2   │ Tile 3   │
                      │ 256x256  │ 256x256  │ 256x256  │
                      └──────────┴──────────┴──────────┘
                           │
                           │ 需要对应的GT tile
                           ▼

GT图片: 512x512
┌─────────────────────┐
│                     │     坐标映射：
│      512x512        │     scale = 512 / 512 = 1.0
│                     │     GT tile = LR tile * 1.0
└─────────────────────┘
         │
         │ 提取对应区域
         ▼
┌──────────┬──────────┬──────────┐
│ GT Tile1 │ GT Tile2 │ GT Tile3 │  ← 坐标完全对应
│ 256x256  │ 256x256  │ 256x256  │
└──────────┴──────────┴──────────┘
```

### 场景2: GT尺寸是上采样LR的2倍

```
原始LR: 128x128 → 上采样LR: 512x512

LR Tile在上采样空间:
┌─────────────────────┐
│  (0, 256, 0, 256)   │
│        Tile 1       │
│      256x256        │
└─────────────────────┘
         │
         │ 坐标映射
         ▼

GT图片: 1024x1024
┌───────────────────────────────────┐
│                                   │
│           scale_h = 1024/512 = 2  │
│           scale_w = 1024/512 = 2  │
│                                   │
│    GT tile坐标:                   │
│    h: 0*2 = 0 → 256*2 = 512       │
│    w: 0*2 = 0 → 256*2 = 512       │
│                                   │
│    ┌─────────────────────┐        │
│    │   GT Tile 1         │        │
│    │   (0,512,0,512)     │        │
│    │   512x512           │        │
│    └─────────────────────┘        │
│                                   │
└───────────────────────────────────┘
         │
         │ Resize到LR tile尺寸
         ▼
    ┌──────────┐
    │  Tile 1  │  ← 最终用于生成edge map
    │ 256x256  │
    └──────────┘
```

## 📊 详细坐标映射过程

### 完整流程示例

**输入参数**:
- 原始LR: 256x256
- 上采样LR: 2048x2048 (8x upscale)
- GT: 2048x2048
- vqgantile_size: 1280
- vqgantile_stride: 1000

#### Step 1: Tile切分

```
上采样LR (2048x2048) 被切分为:

Tile布局:
┌─────────┬─────────┐
│ Tile 1  │ Tile 2  │  高度: 0-1280, 1000-2048
│ 1280x   │ 1048x   │  宽度: 0-1280, 1000-2048
│ 1280    │ 1280    │
├─────────┼─────────┤
│ Tile 3  │ Tile 4  │
│ 1280x   │ 1048x   │
│ 1048    │ 1048    │
└─────────┴─────────┘

Tile坐标:
- Tile 1: (0, 1280, 0, 1280)       → 1280x1280
- Tile 2: (0, 1280, 1000, 2048)    → 1280x1048
- Tile 3: (1000, 2048, 0, 1280)    → 1048x1280
- Tile 4: (1000, 2048, 1000, 2048) → 1048x1048

重叠区域 (橙色):
┌─────────┬─────────┐
│ T1      │ T2      │
│    ┌────┼────┐    │
│    │████│████│    │  ← 水平重叠280像素
│    └────┼────┘    │
├─────────┼─────────┤
│    ████████████   │  ← 垂直重叠280像素
├─────────┼─────────┤
│ T3      │ T4      │
└─────────┴─────────┘
```

#### Step 2: 处理Tile 1

```
LR Tile 1坐标: (0, 1280, 0, 1280)
上采样LR空间: 2048x2048
GT空间: 2048x2048

计算缩放因子:
scale_h = 2048 / 2048 = 1.0
scale_w = 2048 / 2048 = 1.0

映射到GT空间:
h_start_gt = 0 * 1.0 = 0
h_end_gt = 1280 * 1.0 = 1280
w_start_gt = 0 * 1.0 = 0
w_end_gt = 1280 * 1.0 = 1280

提取GT tile: gt_image[0:1280, 0:1280]

GT图片 (2048x2048):
┌─────────────────────────┐
│ ╔═══════════╗           │
│ ║ GT Tile 1 ║           │
│ ║ 1280x1280 ║           │
│ ║           ║           │
│ ╚═══════════╝           │
│                         │
│                         │
│                         │
└─────────────────────────┘

生成Edge Map:
GT Tile (1280x1280) → Canny检测 → Edge Map (1280x1280)
```

#### Step 3: 处理Tile 2（边界tile）

```
LR Tile 2坐标: (0, 1280, 1000, 2048)
实际尺寸: 1280x1048 (不是正方形！)

计算:
scale = 1.0
h_start_gt = 0
h_end_gt = 1280
w_start_gt = 1000
w_end_gt = 2048

GT Tile 2: gt_image[0:1280, 1000:2048]
实际尺寸: 1280x1048

GT图片:
┌─────────────────────────┐
│           ╔═══════════╗ │
│           ║ GT Tile 2 ║ │  ← 右边界tile
│           ║ 1280x1048 ║ │
│           ║           ║ │
│           ╚═══════════╝ │
│                         │
│                         │
│                         │
└─────────────────────────┘

注意: 尺寸是1280x1048，匹配LR tile的尺寸
无需resize，直接生成edge map
```

## 🔢 坐标计算公式详解

### 基础公式

```python
# 给定:
original_lr_size = (H_lr_orig, W_lr_orig)  # 原始LR尺寸
upsampled_lr_size = (H_lr_up, W_lr_up)     # 上采样后LR尺寸
gt_size = (H_gt, W_gt)                      # GT图片尺寸
tile_coords = (h_start, h_end, w_start, w_end)  # Tile在上采样空间的坐标

# 计算缩放因子（关键！）
scale_h = H_gt / H_lr_up
scale_w = W_gt / W_lr_up

# 映射到GT空间
h_start_gt = int(h_start * scale_h)
h_end_gt = int(h_end * scale_h)
w_start_gt = int(w_start * scale_w)
w_end_gt = int(w_end * scale_w)

# 提取GT tile
gt_tile = gt_image[:, :, h_start_gt:h_end_gt, w_start_gt:w_end_gt]

# 如果需要，resize到LR tile尺寸
target_h = h_end - h_start
target_w = w_end - w_start
if gt_tile.shape[2] != target_h or gt_tile.shape[3] != target_w:
    gt_tile = F.interpolate(gt_tile, size=(target_h, target_w))
```

### 为什么是H_gt / H_lr_up而不是H_gt / H_lr_orig？

❌ **错误理解**:
```python
# 这样是错误的！
scale = H_gt / H_lr_orig  # 例如: 2048 / 256 = 8

# 问题: tile坐标是在上采样空间(2048x2048)中的
# 用原始LR空间(256x256)的比例会导致坐标错误
```

✅ **正确理解**:
```python
# 这样是正确的！
scale = H_gt / H_lr_up  # 例如: 2048 / 2048 = 1

# 原因: tile坐标已经在上采样空间(2048x2048)中
# 需要从上采样空间直接映射到GT空间
```

**图解原因**:
```
原始LR (256)  → [不相关] → Tile坐标不在这个空间
     ↓
上采样LR (2048) → [这里！] → Tile坐标在这个空间
     ↓                ↓
     └────────映射────→ GT空间 (2048)
```

## 🎯 实际案例走查

### 案例: 128x128 LR → 512x512 HR

```
Step 1: 读取LR
┌─────┐
│ LR  │  128x128
└─────┘

Step 2: 上采样LR (4x)
┌─────────────┐
│ Upsampled   │  512x512
│     LR      │
└─────────────┘

Step 3: Tile切分 (假设vqgantile_size=256, stride=200)
┌──────┬──────┬──────┐
│ T1   │ T2   │ T3   │  每个256x256
│256x  │256x  │256x  │  重叠56像素
│256   │256   │256   │
└──────┴──────┴──────┘

坐标:
- T1: (0, 256, 0, 256)
- T2: (0, 256, 200, 456)
- T3: (0, 256, 400, 512) → 实际(0, 256, 256, 512)

Step 4: 加载GT图片
┌─────────────┐
│     GT      │  512x512 (与upsampled LR相同)
└─────────────┘

Step 5: 提取GT tiles (scale = 512/512 = 1.0)

GT Tile 1: gt[0:256, 0:256]
┌──────┐
│GT T1 │  256x256
└──────┘

GT Tile 2: gt[0:256, 200:456]
   ┌──────┐
   │GT T2 │  256x256
   └──────┘

GT Tile 3: gt[0:256, 256:512]
            ┌──────┐
            │GT T3 │  256x256
            └──────┘

Step 6: 生成Edge Maps
┌──────┐   ┌──────┐   ┌──────┐
│Edge1 │   │Edge2 │   │Edge3 │  每个256x256
└──────┘   └──────┘   └──────┘

Step 7: 处理每个tile
LR T1 + Edge1 → Process → Result1
LR T2 + Edge2 → Process → Result2
LR T3 + Edge3 → Process → Result3

Step 8: 高斯融合
Result1 + Result2 + Result3 (with gaussian weights)
            ↓
    ┌─────────────┐
    │   Final     │  512x512
    │   Result    │  无缝拼接
    └─────────────┘
```

## 🔍 边界情况处理

### 情况1: GT tile超出边界

```python
# 问题: 计算出的坐标可能超出GT图片范围
h_end_gt = 2500  # 但GT只有2048

# 解决: 边界检查
h_end_gt = min(h_end_gt, H_gt)  # 2048

# 结果: tile尺寸可能小于预期
tile_h = h_end_gt - h_start_gt  # 可能 < vqgantile_size
```

**图解**:
```
计算出的GT tile (超出范围):
┌─────────────────┐
│     GT Image    │
│                 │
│    ┌────────────┼───┐ ← 超出边界
│    │  Tile      │ X │
│    └────────────┼───┘
└─────────────────┘

实际提取的GT tile (截断):
┌─────────────────┐
│     GT Image    │
│                 │
│    ┌────────────┤
│    │  Tile      │ ← 截断到边界
│    └────────────┤
└─────────────────┘
```

### 情况2: GT尺寸小于上采样LR

```
上采样LR: 2048x2048
GT: 1024x1024 (比较小)

scale = 1024 / 2048 = 0.5

LR Tile: (0, 1280, 0, 1280)
GT Tile: (0, 640, 0, 640)  ← 只有一半大小

解决: Resize GT tile
gt_tile = F.interpolate(gt_tile, size=(1280, 1280))

结果:
┌─────────────┐     ┌─────────────────────┐
│  GT Tile    │  →  │  Resized GT Tile    │
│  640x640    │     │     1280x1280       │
└─────────────┘     └─────────────────────┘
```

### 情况3: 非正方形tile

```
图片边界的tile可能不是正方形:

LR图片: 2048x2048
Tile设置: size=1280, stride=1000

最后一个tile:
h: 1000 → 2048 (实际高度: 1048)
w: 1000 → 2048 (实际宽度: 1048)

GT Tile也是非正方形:
┌─────────────┐
│             │
│             │  ← 1048x1048
│             │
└─────────────┘

处理: 
- Edge map也会是1048x1048
- 完美匹配，无需特殊处理
```

## 📐 重叠区域的高斯融合

### 高斯权重矩阵

```
单个tile的权重分布 (256x256):

      0.1  0.3  0.5  0.7  0.9  1.0  0.9  0.7  0.5  0.3  0.1
    ┌─────────────────────────────────────────────────────┐
0.1 │ .   .   .   .   .   .   .   .   .   .   .          │
0.3 │ .   .   .   .   *   *   *   .   .   .   .          │
0.5 │ .   .   *   *   *   *   *   *   *   .   .          │
0.7 │ .   *   *   *   *   *   *   *   *   *   .          │
0.9 │ .   *   *   *   █   █   █   *   *   *   .          │  ← 中心权重最高
1.0 │ .   *   *   *   █   █   █   *   *   *   .          │
0.9 │ .   *   *   *   █   █   █   *   *   *   .          │
0.7 │ .   *   *   *   *   *   *   *   *   *   .          │
0.5 │ .   .   *   *   *   *   *   *   *   .   .          │
0.3 │ .   .   .   .   *   *   *   .   .   .   .          │
0.1 │ .   .   .   .   .   .   .   .   .   .   .          │
    └─────────────────────────────────────────────────────┘

图例:
█ = 权重1.0 (中心)
* = 权重0.5-0.9
. = 权重0.1-0.4 (边缘)
```

### 重叠区域融合

```
两个相邻tile的重叠区域:

Tile 1权重:          Tile 2权重:
┌─────────────┐      ┌─────────────┐
│ 1.0    0.5  │      │  0.5   1.0  │
│ 0.9    0.4  │      │  0.6   0.9  │
│ 0.8    0.3  │      │  0.7   0.8  │
└─────────────┘      └─────────────┘
        └────重叠────┘

融合结果:
Result = (Tile1 * W1 + Tile2 * W2) / (W1 + W2)

在重叠区域:
┌─────────────────────┐
│  平滑过渡          │
│  无明显接缝        │
└─────────────────────┘
```

## 🎓 关键要点总结

### ✅ 正确做法

1. **坐标空间一致性**
   ```python
   # tile坐标在上采样空间
   scale = H_gt / H_lr_upsampled  # ✓ 正确
   ```

2. **边界检查**
   ```python
   h_end_gt = min(h_end_gt, H_gt)  # ✓ 防止越界
   ```

3. **尺寸匹配**
   ```python
   if gt_tile.size != lr_tile.size:
       gt_tile = resize(gt_tile, lr_tile.size)  # ✓ 保证匹配
   ```

4. **高斯融合**
   ```python
   spliter.update_gaussian(result, coords)  # ✓ 平滑拼接
   ```

### ❌ 常见错误

1. **错误的缩放因子**
   ```python
   scale = H_gt / H_lr_original  # ✗ 错误！
   ```

2. **忘记边界检查**
   ```python
   gt_tile = gt[h_start:h_end, ...]  # ✗ 可能越界
   ```

3. **尺寸不匹配**
   ```python
   # GT tile: 512x512
   # LR tile: 256x256
   # 直接使用会出错！  # ✗
   ```

4. **简单拼接**
   ```python
   result = concat(tile1, tile2)  # ✗ 会有接缝
   ```

## 🔗 代码位置

- **核心函数**: `extract_tile_from_gt()` (line 175-230)
- **Spliter类**: `ImageSpliterWithEdge` (line 340-400)
- **使用示例**: `sr_val_ddpm_text_T_vqganfin_oldcanvas_tile_edge.py` (line 600-650)

---

**提示**: 理解这个坐标映射关系是正确实现tile-based edge processing的关键！

